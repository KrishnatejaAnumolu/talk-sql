// pages/api/execute-sql.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { getConnection, DBConnectionParams } from "../../lib/db";
import mysql from "mysql2/promise";

interface ExecuteSqlResponse {
  results?: any[];
  fields?: mysql.FieldPacket[];
  error?: string;
}

// Basic validation: only allow SELECT statements
function isValidSelectQuery(sql: string): boolean {
  const trimmedSql = sql.trim().toUpperCase();
  // This is a basic check. For production, a more robust SQL parser/validator might be needed.
  if (!trimmedSql.startsWith("SELECT")) {
    return false;
  }
  // Deny common mutating keywords if they appear outside of string literals or comments
  const forbiddenKeywords = [
    "INSERT",
    "UPDATE",
    "DELETE",
    "DROP",
    "CREATE",
    "ALTER",
    "TRUNCATE",
    "GRANT",
    "REVOKE",
  ];

  // A more sophisticated check would involve parsing, but for now:
  // Check if any forbidden keyword exists as a whole word
  const sqlWithoutStrings = sql
    .replace(/'[^']*'/g, "''")
    .replace(/"[^"]*"/g, '""'); // Remove string literals
  const upperSqlWithoutStrings = sqlWithoutStrings.toUpperCase();

  for (const keyword of forbiddenKeywords) {
    const regex = new RegExp(`\\b${keyword}\\b`);
    if (regex.test(upperSqlWithoutStrings)) {
      // Allow if it's part of a subquery in a SELECT, but this is hard to check simply
      // For now, a simple presence check is a starting point.
      // A more robust solution would be to ensure it's not the *primary* command.
      // E.g. "SELECT column FROM table WHERE notes LIKE '%UPDATE%'" is OK.
      // But "UPDATE table SET ..." is NOT.
      // The current `trimmedSql.startsWith('SELECT')` handles the primary command.
      // This secondary check is for keywords embedded elsewhere.
      // This simplistic check might give false positives.
      // Let's rely more on the startsWith('SELECT') and LLM prompt for now.
    }
  }
  return trimmedSql.startsWith("SELECT"); // Keep it simple and rely on startsWith for now
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ExecuteSqlResponse>
) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  const { sqlQuery, dbConfig } = req.body as {
    sqlQuery: string;
    dbConfig: DBConnectionParams;
  };

  if (!sqlQuery || !dbConfig) {
    return res
      .status(400)
      .json({ error: "SQL query and database configuration are required." });
  }

  if (!isValidSelectQuery(sqlQuery)) {
    return res
      .status(403)
      .json({
        error:
          "Invalid query. Only SELECT statements are allowed. The AI might have generated a non-SELECT query.",
      });
  }

  let connection;
  try {
    connection = await getConnection(dbConfig);
    const [results, fields] = await connection.execute(sqlQuery);
    await connection.end();
    // Convert results to plain JS objects if they are RowDataPacket or similar
    const plainResults = Array.isArray(results)
      ? results.map((row) => ({ ...row }))
      : results;
    res.status(200).json({ results: plainResults, fields });
  } catch (error: any) {
    console.error("Execute SQL API Error:", error);
    let userErrorMessage = "Error executing SQL query.";
    if (
      error.code === "ER_PARSE_ERROR" ||
      error.code === "ER_BAD_FIELD_ERROR" ||
      error.code === "ER_NO_SUCH_TABLE"
    ) {
      userErrorMessage = `Database error: ${
        error.sqlMessage || error.message
      }. This might be due to an invalid query generated by the AI or an issue with your database schema.`;
    } else if (error.code === "ER_TABLEACCESS_DENIED_ERROR") {
      userErrorMessage = `Database error: ${
        error.sqlMessage || error.message
      }. The connected user might not have permission to access the requested table(s).`;
    }
    res.status(500).json({ error: userErrorMessage });
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}
